<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/archiverjs/node-archiver">archiver (v1.3.0)</a>
</h1>
<h4>a streaming interface for archive generation</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver">module archiver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.archiver">
            function <span class="apidocSignatureSpan"></span>archiver
            <span class="apidocSignatureSpan">(format, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core">
            function <span class="apidocSignatureSpan">archiver.</span>core
            <span class="apidocSignatureSpan">(format, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.create">
            function <span class="apidocSignatureSpan">archiver.</span>create
            <span class="apidocSignatureSpan">(format, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json">
            function <span class="apidocSignatureSpan">archiver.</span>json
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.registerFormat">
            function <span class="apidocSignatureSpan">archiver.</span>registerFormat
            <span class="apidocSignatureSpan">(format, module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar">
            function <span class="apidocSignatureSpan">archiver.</span>tar
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip">
            function <span class="apidocSignatureSpan">archiver.</span>zip
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">archiver.</span>core.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">archiver.</span>json.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">archiver.</span>tar.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">archiver.</span>zip.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.core">module archiver.core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.core">
            function <span class="apidocSignatureSpan">archiver.</span>core
            <span class="apidocSignatureSpan">(format, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.super_">
            function <span class="apidocSignatureSpan">archiver.core.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.core.prototype">module archiver.core.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._abort">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._append">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_append
            <span class="apidocSignatureSpan">(filepath, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._finalize">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._maybeFinalize">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_maybeFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._moduleAppend">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleAppend
            <span class="apidocSignatureSpan">(source, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._moduleFinalize">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleFinalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._modulePipe">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_modulePipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._moduleSupports">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleSupports
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._moduleUnpipe">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleUnpipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._normalizeEntryData">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_normalizeEntryData
            <span class="apidocSignatureSpan">(data, stats)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._onModuleError">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onModuleError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._onQueueDrain">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onQueueDrain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._onQueueTask">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onQueueTask
            <span class="apidocSignatureSpan">(task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._onStatQueueTask">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onStatQueueTask
            <span class="apidocSignatureSpan">(task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._shutdown">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_shutdown
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._transform">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype._updateQueueTaskWithStats">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_updateQueueTaskWithStats
            <span class="apidocSignatureSpan">(task, stats)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.abort">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.append">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>append
            <span class="apidocSignatureSpan">(source, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.bulk">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>bulk
            <span class="apidocSignatureSpan">(mappings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.directory">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>directory
            <span class="apidocSignatureSpan">(dirpath, destpath, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.file">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>file
            <span class="apidocSignatureSpan">(filepath, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.finalize">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.glob">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>glob
            <span class="apidocSignatureSpan">(pattern, options, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.pointer">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>pointer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.setFormat">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>setFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.setModule">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>setModule
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.core.prototype.use">
            function <span class="apidocSignatureSpan">archiver.core.prototype.</span>use
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.json">module archiver.json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json.json">
            function <span class="apidocSignatureSpan">archiver.</span>json
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json.super_">
            function <span class="apidocSignatureSpan">archiver.json.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.json.prototype">module archiver.json.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json.prototype._transform">
            function <span class="apidocSignatureSpan">archiver.json.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json.prototype._writeStringified">
            function <span class="apidocSignatureSpan">archiver.json.prototype.</span>_writeStringified
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json.prototype.append">
            function <span class="apidocSignatureSpan">archiver.json.prototype.</span>append
            <span class="apidocSignatureSpan">(source, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.json.prototype.finalize">
            function <span class="apidocSignatureSpan">archiver.json.prototype.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.tar">module archiver.tar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.tar">
            function <span class="apidocSignatureSpan">archiver.</span>tar
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.tar.prototype">module archiver.tar.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.prototype._onCompressorError">
            function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>_onCompressorError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.prototype.append">
            function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>append
            <span class="apidocSignatureSpan">(source, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.prototype.finalize">
            function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.prototype.on">
            function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.prototype.pipe">
            function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>pipe
            <span class="apidocSignatureSpan">(destination, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.tar.prototype.unpipe">
            function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>unpipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.zip">module archiver.zip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip.zip">
            function <span class="apidocSignatureSpan">archiver.</span>zip
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.archiver.zip.prototype">module archiver.zip.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip.prototype.append">
            function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>append
            <span class="apidocSignatureSpan">(source, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip.prototype.finalize">
            function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip.prototype.on">
            function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip.prototype.pipe">
            function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.archiver.zip.prototype.unpipe">
            function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>unpipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver" id="apidoc.module.archiver">module archiver</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.archiver" id="apidoc.element.archiver.archiver">
        function <span class="apidocSignatureSpan"></span>archiver
        <span class="apidocSignatureSpan">(format, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">archiver = function (format, options) {
  return vending.create(format, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core" id="apidoc.element.archiver.core">
        function <span class="apidocSignatureSpan">archiver.</span>core
        <span class="apidocSignatureSpan">(format, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">core = function (format, options) {
  if (!(this instanceof Archiver)) {
    return new Archiver(format, options);
  }

  if (typeof format !== 'string') {
    options = format;
    format = 'zip';
  }

  options = this.options = util.defaults(options, {
    highWaterMark: 1024 * 1024,
    statConcurrency: 4
  });

  Transform.call(this, options);

  this._entries = [];
  this._format = false;
  this._module = false;
  this._pending = 0;
  this._pointer = 0;

  this._queue = async.queue(this._onQueueTask.bind(this), 1);
  this._queue.drain = this._onQueueDrain.bind(this);

  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);

  this._state = {
    aborted: false,
    finalize: false,
    finalizing: false,
    finalized: false,
    modulePiped: false
  };

  this._streams = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.create" id="apidoc.element.archiver.create">
        function <span class="apidocSignatureSpan">archiver.</span>create
        <span class="apidocSignatureSpan">(format, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (format, options) {
  if (formats[format]) {
    var instance = new Archiver(format, options);
    instance.setFormat(format);
    instance.setModule(new formats[format](options));

    return instance;
  } else {
    throw new Error('create(' + format + '): format not registered');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @constructor
* @param  {String} format The archive format to use.
* @param  {Object} options See [Archiver]{@link Archiver}
* @return {Archiver}
*/
var vending = function(format, options) {
 return vending.<span class="apidocCodeKeywordSpan">create</span>(format, options);
};

/**
* Creates a new Archiver instance.
*
* @param  {String} format The archive format to use.
* @param  {Object} options See [Archiver]{@link Archiver}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.json" id="apidoc.element.archiver.json">
        function <span class="apidocSignatureSpan">archiver.</span>json
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (options) {
  if (!(this instanceof Json)) {
    return new Json(options);
  }

  options = this.options = util.defaults(options, {});

  Transform.call(this, options);

  this.supports = {
    directory: true
  };

  this.files = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.registerFormat" id="apidoc.element.archiver.registerFormat">
        function <span class="apidocSignatureSpan">archiver.</span>registerFormat
        <span class="apidocSignatureSpan">(format, module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerFormat = function (format, module) {
  if (formats[format]) {
    throw new Error('register(' + format + '): format already registered');
  }

  if (typeof module !== 'function') {
    throw new Error('register(' + format + '): format module invalid');
  }

  if (typeof module.prototype.append !== 'function' || typeof module.prototype.finalize !== 'function') {
    throw new Error('register(' + format + '): format module missing methods');
  }

  formats[format] = module;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof module.prototype.append !== 'function' || typeof module.prototype.finalize !== 'function') {
    throw new Error('register(' + format + '): format module missing methods');
  }

  formats[format] = module;
};

vending.<span class="apidocCodeKeywordSpan">registerFormat</span>('zip', require('./lib/plugins/zip'));
vending.registerFormat('tar', require('./lib/plugins/tar'));
vending.registerFormat('json', require('./lib/plugins/json'));

module.exports = vending;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.tar" id="apidoc.element.archiver.tar">
        function <span class="apidocSignatureSpan">archiver.</span>tar
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tar = function (options) {
  if (!(this instanceof Tar)) {
    return new Tar(options);
  }

  options = this.options = util.defaults(options, {
    gzip: false
  });

  if (typeof options.gzipOptions !== 'object') {
    options.gzipOptions = {};
  }

  this.supports = {
    directory: true
  };

  this.engine = engine.pack(options);
  this.compressor = false;

  if (options.gzip) {
    this.compressor = zlib.createGzip(options.gzipOptions);
    this.compressor.on('error', this._onCompressorError.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.zip" id="apidoc.element.archiver.zip">
        function <span class="apidocSignatureSpan">archiver.</span>zip
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function (options) {
  if (!(this instanceof Zip)) {
    return new Zip(options);
  }

  options = this.options = util.defaults(options, {
    comment: '',
    forceUTC: false,
    store: false
  });

  this.supports = {
    directory: true
  };

  this.engine = new engine(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.core" id="apidoc.module.archiver.core">module archiver.core</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.core.core" id="apidoc.element.archiver.core.core">
        function <span class="apidocSignatureSpan">archiver.</span>core
        <span class="apidocSignatureSpan">(format, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">core = function (format, options) {
  if (!(this instanceof Archiver)) {
    return new Archiver(format, options);
  }

  if (typeof format !== 'string') {
    options = format;
    format = 'zip';
  }

  options = this.options = util.defaults(options, {
    highWaterMark: 1024 * 1024,
    statConcurrency: 4
  });

  Transform.call(this, options);

  this._entries = [];
  this._format = false;
  this._module = false;
  this._pending = 0;
  this._pointer = 0;

  this._queue = async.queue(this._onQueueTask.bind(this), 1);
  this._queue.drain = this._onQueueDrain.bind(this);

  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);

  this._state = {
    aborted: false,
    finalize: false,
    finalizing: false,
    finalized: false,
    modulePiped: false
  };

  this._streams = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.super_" id="apidoc.element.archiver.core.super_">
        function <span class="apidocSignatureSpan">archiver.core.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.core.prototype" id="apidoc.module.archiver.core.prototype">module archiver.core.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.core.prototype._abort" id="apidoc.element.archiver.core.prototype._abort">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_abort = function () {
  this._state.aborted = true;
  this._queue.kill();
  this._statQueue.kill();

  if (this._queue.idle()) {
    this._shutdown();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return {this}
*/
Archiver.prototype.abort = function() {
 if (this._state.aborted || this._state.finalized) {
   return this;
 }

 this.<span class="apidocCodeKeywordSpan">_abort</span>();

 return this;
};

/**
* Appends an input source (text string, buffer, or stream) to the instance.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._append" id="apidoc.element.archiver.core.prototype._append">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_append
        <span class="apidocSignatureSpan">(filepath, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_append = function (filepath, data) {
  data = data || {};

  var task = {
    source: null,
    filepath: filepath
  };

  if (!data.name) {
    data.name = filepath;
  }

  data.sourcePath = filepath;
  task.data = data;

  if (data.stats &amp;&amp; data.stats instanceof fs.Stats) {
    task = this._updateQueueTaskWithStats(task, data.stats);
    this._queue.push(task);
  } else {
    this._statQueue.push(task);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          }
        }
      } catch(e) {
        self.emit('error', e);
        return;
      }

      self.<span class="apidocCodeKeywordSpan">_append</span>(filepath, entryData);
    });
  });

  return this;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._finalize" id="apidoc.element.archiver.core.prototype._finalize">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finalize = function () {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return;
  }

  this._state.finalizing = true;

  this._moduleFinalize();

  this._state.finalizing = false;
  this._state.finalized = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Archiver.prototype._maybeFinalize = function() {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return false;
  }

  if (this._state.finalize &amp;&amp; this._pending === 0 &amp;&amp; this._queue.idle() &amp;&amp; this._statQueue.idle()) {
    this.<span class="apidocCodeKeywordSpan">_finalize</span>();
    return true;
  }

  return false;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._maybeFinalize" id="apidoc.element.archiver.core.prototype._maybeFinalize">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_maybeFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_maybeFinalize = function () {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return false;
  }

  if (this._state.finalize &amp;&amp; this._pending === 0 &amp;&amp; this._queue.idle() &amp;&amp; this._statQueue.idle()) {
    this._finalize();
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  this._append(filepath, entryData);
}

function onWalkEnd() {
  this._pending--;
  this.<span class="apidocCodeKeywordSpan">_maybeFinalize</span>();
}

function onWalkError(err) {
  this.emit('error', 'directory: ' + err);
}

var walker = walkdir(dirpath);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._moduleAppend" id="apidoc.element.archiver.core.prototype._moduleAppend">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleAppend
        <span class="apidocSignatureSpan">(source, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_moduleAppend = function (source, data, callback) {
  if (this._state.aborted) {
    callback();
    return;
  }

  this._module.append(source, data, function(err) {
    this._task = null;

    if (this._state.aborted) {
      this._shutdown();
      return;
    }

    if (err) {
      this.emit('error', err);
      setImmediate(callback);
      return;
    }

    /**
     * Fires when the entry's input has been processed and appended to the archive.
     *
     * @event Archiver#entry
     * @type {EntryData}
     */
    this.emit('entry', data);
    this._entries.push(data);

    setImmediate(callback);
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Archiver.prototype._onQueueTask = function(task, callback) {
 if (this._state.finalizing || this._state.finalized || this._state.aborted) {
   callback();
   return;
 }

 this._task = task;
 this.<span class="apidocCodeKeywordSpan">_moduleAppend</span>(task.source, task.data, callback);
};

/**
* Performs a file stat and reinjects the task back into the queue.
*
* @private
* @param  {Object} task
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._moduleFinalize" id="apidoc.element.archiver.core.prototype._moduleFinalize">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleFinalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_moduleFinalize = function () {
  if (typeof this._module.finalize === 'function') {
    this._module.finalize();
  } else if (typeof this._module.end === 'function') {
    this._module.end();
  } else {
    this.emit('error', new Error('module: no suitable finalize/end method found'));
    return;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Archiver.prototype._finalize = function() {
 if (this._state.finalizing || this._state.finalized || this._state.aborted) {
   return;
 }

 this._state.finalizing = true;

 this.<span class="apidocCodeKeywordSpan">_moduleFinalize</span>();

 this._state.finalizing = false;
 this._state.finalized = true;
};

/**
* Checks the various state variables to determine if we can `finalize`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._modulePipe" id="apidoc.element.archiver.core.prototype._modulePipe">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_modulePipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_modulePipe = function () {
  this._module.on('error', this._onModuleError.bind(this));
  this._module.pipe(this);
  this._state.modulePiped = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 if (this._state.module) {
   this.emit('error', new Error('module: module already set'));
   return this;
 }

 this._module = module;
 this.<span class="apidocCodeKeywordSpan">_modulePipe</span>();

 return this;
};

/**
* Returns the current length (in bytes) that has been emitted.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._moduleSupports" id="apidoc.element.archiver.core.prototype._moduleSupports">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleSupports
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_moduleSupports = function (key) {
  if (!this._module.supports || !this._module.supports[key]) {
    return false;
  }

  return this._module.supports[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object}
 */
Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
if (stats.isFile()) {
  task.data.type = 'file';
  task.data.sourceType = 'stream';
  task.source = util.lazyReadStream(task.filepath);
} else if (stats.isDirectory() &amp;&amp; this.<span class="apidocCodeKeywordSpan">_moduleSupports</span>('directory'
;)) {
  task.data.name = util.trailingSlashIt(task.data.name);
  task.data.type = 'directory';
  task.data.sourcePath = util.trailingSlashIt(task.filepath);
  task.data.sourceType = 'buffer';
  task.source = new Buffer(0);
} else {
  return task;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._moduleUnpipe" id="apidoc.element.archiver.core.prototype._moduleUnpipe">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_moduleUnpipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_moduleUnpipe = function () {
  this._module.unpipe(this);
  this._state.modulePiped = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Unpipes the module and ends our internal stream.
*
* @private
* @return void
*/
Archiver.prototype._shutdown = function() {
 this.<span class="apidocCodeKeywordSpan">_moduleUnpipe</span>();
 this.end();
};

/**
* Tracks the bytes emitted by our internal stream.
*
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._normalizeEntryData" id="apidoc.element.archiver.core.prototype._normalizeEntryData">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_normalizeEntryData
        <span class="apidocSignatureSpan">(data, stats)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_normalizeEntryData = function (data, stats) {
  data = util.defaults(data, {
    type: 'file',
    name: null,
    date: null,
    mode: null,
    prefix: null,
    sourcePath: null,
    stats: false
  });

  if (stats &amp;&amp; data.stats === false) {
    data.stats = stats;
  }

  var isDir = data.type === 'directory';

  if (data.name) {
    if (typeof data.prefix === 'string' &amp;&amp; '' !== data.prefix) {
      data.name = data.prefix + '/' + data.name;
      data.prefix = null;
    }

    data.name = util.sanitizePath(data.name);

    if (data.name.slice(-1) === '/') {
      isDir = true;
      data.type = 'directory';
    } else if (isDir) {
      data.name += '/';
    }
  }

  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644
  if (typeof data.mode === 'number') {
    if (win32) {
      data.mode &amp;= 511;
    } else {
      data.mode &amp;= 4095
    }
  } else if (data.stats &amp;&amp; data.mode === null) {
    if (win32) {
      data.mode = data.stats.mode &amp; 511;
    } else {
      data.mode = data.stats.mode &amp; 4095;
    }

    // stat isn't reliable on windows; force 0755 for dir
    if (win32 &amp;&amp; isDir) {
      data.mode = 493;
    }
  } else if (data.mode === null) {
    data.mode = isDir ? 493 : 420;
  }

  if (data.stats &amp;&amp; data.date === null) {
    data.date = data.stats.mtime;
  } else {
    data.date = util.dateify(data.date);
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   task.data.sourcePath = util.trailingSlashIt(task.filepath);
   task.data.sourceType = 'buffer';
   task.source = new Buffer(0);
 } else {
   return task;
 }

 task.data = this.<span class="apidocCodeKeywordSpan">_normalizeEntryData</span>(task.data, stats);
 return task;
};

/**
* Aborts the archiving process, taking a best-effort approach, by:
*
* - removing any pending queue tasks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._onModuleError" id="apidoc.element.archiver.core.prototype._onModuleError">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onModuleError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onModuleError = function (err) {
  this.emit('error', err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._onQueueDrain" id="apidoc.element.archiver.core.prototype._onQueueDrain">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onQueueDrain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onQueueDrain = function () {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return;
  }

  if (this._state.finalize &amp;&amp; this._pending === 0 &amp;&amp; this._queue.idle() &amp;&amp; this._statQueue.idle()) {
    this._finalize();
    return;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._onQueueTask" id="apidoc.element.archiver.core.prototype._onQueueTask">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onQueueTask
        <span class="apidocSignatureSpan">(task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onQueueTask = function (task, callback) {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    callback();
    return;
  }

  this._task = task;
  this._moduleAppend(task.source, task.data, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._onStatQueueTask" id="apidoc.element.archiver.core.prototype._onStatQueueTask">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_onStatQueueTask
        <span class="apidocSignatureSpan">(task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onStatQueueTask = function (task, callback) {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    callback();
    return;
  }

  fs.stat(task.filepath, function(err, stats) {
    if (this._state.aborted) {
      setImmediate(callback);
      return;
    }

    if (err) {
      this.emit('error', err);
      setImmediate(callback);
      return;
    }

    task = this._updateQueueTaskWithStats(task, stats);

    if (task.source !== null) {
      this._queue.push(task);
      setImmediate(callback);
    } else {
      this.emit('error', new Error('unsupported entry: ' + task.filepath));
      setImmediate(callback);
      return;
    }
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._shutdown" id="apidoc.element.archiver.core.prototype._shutdown">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_shutdown
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_shutdown = function () {
  this._moduleUnpipe();
  this.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Archiver.prototype._abort = function() {
 this._state.aborted = true;
 this._queue.kill();
 this._statQueue.kill();

 if (this._queue.idle()) {
   this.<span class="apidocCodeKeywordSpan">_shutdown</span>();
 }
};

/**
* Internal helper for appending files.
*
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._transform" id="apidoc.element.archiver.core.prototype._transform">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  if (chunk) {
    this._pointer += chunk.length;
  }

  callback(null, chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype._updateQueueTaskWithStats" id="apidoc.element.archiver.core.prototype._updateQueueTaskWithStats">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>_updateQueueTaskWithStats
        <span class="apidocSignatureSpan">(task, stats)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateQueueTaskWithStats = function (task, stats) {
  if (stats.isFile()) {
    task.data.type = 'file';
    task.data.sourceType = 'stream';
    task.source = util.lazyReadStream(task.filepath);
  } else if (stats.isDirectory() &amp;&amp; this._moduleSupports('directory')) {
    task.data.name = util.trailingSlashIt(task.data.name);
    task.data.type = 'directory';
    task.data.sourcePath = util.trailingSlashIt(task.filepath);
    task.data.sourceType = 'buffer';
    task.source = new Buffer(0);
  } else {
    return task;
  }

  task.data = this._normalizeEntryData(task.data, stats);
  return task;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    data.name = filepath;
  }

  data.sourcePath = filepath;
  task.data = data;

  if (data.stats &amp;&amp; data.stats instanceof fs.Stats) {
    task = this.<span class="apidocCodeKeywordSpan">_updateQueueTaskWithStats</span>(task, data.stats);
    this._queue.push(task);
  } else {
    this._statQueue.push(task);
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.abort" id="apidoc.element.archiver.core.prototype.abort">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function () {
  if (this._state.aborted || this._state.finalized) {
    return this;
  }

  this._abort();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.append" id="apidoc.element.archiver.core.prototype.append">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>append
        <span class="apidocSignatureSpan">(source, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (source, data) {
  if (this._state.finalize || this._state.aborted) {
    this.emit('error', new Error('append: queue closed'));
    return this;
  }

  data = this._normalizeEntryData(data);

  if (typeof data.name !== 'string' || data.name.length === 0) {
    this.emit('error', new Error('append: entry name must be a non-empty string value'));
    return this;
  }

  if (data.type === 'directory' &amp;&amp; !this._moduleSupports('directory')) {
    this.emit('error', new Error('append: entries of "directory" type not currently supported by this module'));
    return this;
  }

  source = util.normalizeInputSource(source);

  if (Buffer.isBuffer(source)) {
    data.sourceType = 'buffer';
  } else if (util.isStream(source)) {
    data.sourceType = 'stream';
  } else {
    this.emit('error', new Error('append: input source must be valid Stream or Buffer instance'));
    return this;
  }

  this._queue.push({
    data: data,
    source: source
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// pipe archive data to the file
archive.pipe(output);

// append a file from stream
var file1 = __dirname + '/file1.txt';
archive.<span class="apidocCodeKeywordSpan">append</span>(fs.createReadStream(file1), { name: 'file1.txt' });

// append a file from string
archive.append('string cheese!', { name: 'file2.txt' });

// append a file from buffer
var buffer3 = new Buffer('buff it!');
archive.append(buffer3, { name: 'file3.txt' });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.bulk" id="apidoc.element.archiver.core.prototype.bulk">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>bulk
        <span class="apidocSignatureSpan">(mappings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulk = function (mappings) {
  if (process._loggedBulkDeprecation === false) {
    process._loggedBulkDeprecation = true;
    var warning = 'Archiver.bulk() deprecated since 0.21.0';
    if (typeof process !== 'undefined' &amp;&amp; typeof process.emitWarning !== 'undefined') {
      process.emitWarning(warning, 'DeprecationWarning');
    } else {
      console.warn(warning);
    }
  }

  if (this._state.finalize || this._state.aborted) {
    this.emit('error', new Error('bulk: queue closed'));
    return this;
  }

  if (!Array.isArray(mappings)) {
    mappings = [mappings];
  }

  var self = this;
  var files = util.file.normalizeFilesArray(mappings);

  files.forEach(function(file){
    var isExpandedPair = file.orig.expand || false;
    var data = {};
    var dataFunction = false;

    if (typeof file.data === 'function') {
      dataFunction = file.data;
    } else if (typeof file.data === 'object') {
      data = file.data;
    }

    file.src.forEach(function(filepath) {
      var entryData = _.extend({}, data);
      var entryName = isExpandedPair ? file.dest : (file.dest || '') + '/' + filepath;
      entryData.name = util.sanitizePath(entryName);

      if (entryData.name === '.') {
        return;
      }

      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);

          if (typeof entryData !== 'object') {
            throw new Error('bulk: invalid data returned from custom function');
          }
        }
      } catch(e) {
        self.emit('error', e);
        return;
      }

      self._append(filepath, entryData);
    });
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * and [minimatch]{@link https://github.com/isaacs/minimatch#properties} documentation
 * for additional properties.
 * @return {this}
 */
Archiver.prototype.bulk = function(mappings) {
if (process._loggedBulkDeprecation === false) {
  process._loggedBulkDeprecation = true;
  var warning = 'Archiver.<span class="apidocCodeKeywordSpan">bulk</span>() deprecated since 0.21.0';
  if (typeof process !== 'undefined' &amp;&amp; typeof process.emitWarning !== 'undefined') {
    process.emitWarning(warning, 'DeprecationWarning');
  } else {
    console.warn(warning);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.directory" id="apidoc.element.archiver.core.prototype.directory">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>directory
        <span class="apidocSignatureSpan">(dirpath, destpath, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (dirpath, destpath, data) {
  if (this._state.finalize || this._state.aborted) {
    this.emit('error', new Error('directory: queue closed'));
    return this;
  }

  if (typeof dirpath !== 'string' || dirpath.length === 0) {
    this.emit('error', new Error('directory: dirpath must be a non-empty string value'));
    return this;
  }

  this._pending++;

  if (destpath === false) {
    destpath = '';
  } else if (typeof destpath !== 'string'){
    destpath = dirpath;
  }

  var dataFunction = false;
  if (typeof data === 'function') {
    dataFunction = data;
    data = {};
  } else if (typeof data !== 'object') {
    data = {};
  }

  function onWalkPath(filepath, stats){
    var entryData = _.extend({}, data);
    entryData.name = path.relative(dirpath, filepath).replace(/\\/g, '/');
    entryData.prefix = destpath;
    entryData.stats = stats;

    try {
      if (dataFunction) {
        entryData = dataFunction(entryData);

        if (typeof entryData !== 'object') {
          throw new Error('directory: invalid data returned from custom function');
        }
      }
    } catch(e) {
      this.emit('error', e);
      return;
    }

    this._append(filepath, entryData);
  }

  function onWalkEnd() {
    this._pending--;
    this._maybeFinalize();
  }

  function onWalkError(err) {
    this.emit('error', 'directory: ' + err);
  }

  var walker = walkdir(dirpath);

  walker.on('error', onWalkError.bind(this));
  walker.on('directory', onWalkPath.bind(this));
  walker.on('file', onWalkPath.bind(this));
  walker.on('end', onWalkEnd.bind(this));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var buffer3 = new Buffer('buff it!');
archive.append(buffer3, { name: 'file3.txt' });

// append a file
archive.file('file1.txt', { name: 'file4.txt' });

// append files from a directory
archive.<span class="apidocCodeKeywordSpan">directory</span>('subdir/');

// append files from a glob pattern
archive.glob('subdir/*.txt');

// finalize the archive (ie we are done appending files but streams have to finish yet)
archive.finalize();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.file" id="apidoc.element.archiver.core.prototype.file">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>file
        <span class="apidocSignatureSpan">(filepath, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (filepath, data) {
  if (this._state.finalize || this._state.aborted) {
    this.emit('error', new Error('file: queue closed'));
    return this;
  }

  if (typeof filepath !== 'string' || filepath.length === 0) {
    this.emit('error', new Error('file: filepath must be a non-empty string value'));
    return this;
  }

  this._append(filepath, data);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
archive.append('string cheese!', { name: 'file2.txt' });

// append a file from buffer
var buffer3 = new Buffer('buff it!');
archive.append(buffer3, { name: 'file3.txt' });

// append a file
archive.<span class="apidocCodeKeywordSpan">file</span>('file1.txt', { name: 'file4.txt' });

// append files from a directory
archive.directory('subdir/');

// append files from a glob pattern
archive.glob('subdir/*.txt');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.finalize" id="apidoc.element.archiver.core.prototype.finalize">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
  if (this._state.aborted) {
    this.emit('error', new Error('finalize: archive was aborted'));
    return this;
  }

  if (this._state.finalize) {
    this.emit('error', new Error('finalize: archive already finalizing'));
    return this;
  }

  this._state.finalize = true;

  if (this._pending === 0 &amp;&amp; this._queue.idle() &amp;&amp; this._statQueue.idle()) {
    this._finalize();
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// append files from a directory
archive.directory('subdir/');

// append files from a glob pattern
archive.glob('subdir/*.txt');

// finalize the archive (ie we are done appending files but streams have to finish yet)
archive.<span class="apidocCodeKeywordSpan">finalize</span>();
```

## Formats

Archiver ships with out of the box support for TAR and ZIP archives.

You can register additional formats with `registerFormat`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.glob" id="apidoc.element.archiver.core.prototype.glob">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>glob
        <span class="apidocSignatureSpan">(pattern, options, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">glob = function (pattern, options, data) {
  this._pending++;

  options = util.defaults(options, {
    stat: false
  });

  function onGlobEnd() {
    this._pending--;
    this._maybeFinalize();
  }

  function onGlobError(err) {
    this.emit('error', 'glob: ' + err);
  }

  function onGlobMatch(match){
    entryData = _.extend({}, data);

    if (options.cwd) {
      entryData.name = match;
      match = globber._makeAbs(match);
    }

    this._append(match, entryData);
  }

  var globber = glob(pattern, options);
  globber.on('error', onGlobError.bind(this));
  globber.on('match', onGlobMatch.bind(this));
  globber.on('end', onGlobEnd.bind(this));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// append a file
archive.file('file1.txt', { name: 'file4.txt' });

// append files from a directory
archive.directory('subdir/');

// append files from a glob pattern
archive.<span class="apidocCodeKeywordSpan">glob</span>('subdir/*.txt');

// finalize the archive (ie we are done appending files but streams have to finish yet)
archive.finalize();
```

## Formats
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.pointer" id="apidoc.element.archiver.core.prototype.pointer">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>pointer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pointer = function () {
  return this._pointer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var output = fs.createWriteStream(__dirname + '/example.zip');
var archive = archiver('zip', {
    store: true // Sets the compression method to STORE.
});

// listen for all archive data to be written
output.on('close', function() {
  console.log(archive.<span class="apidocCodeKeywordSpan">pointer</span>() + ' total bytes');
  console.log('archiver has been finalized and the output file descriptor has closed.');
});

// good practice to catch this error explicitly
archive.on('error', function(err) {
  throw err;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.setFormat" id="apidoc.element.archiver.core.prototype.setFormat">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>setFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFormat = function (format) {
  if (this._format) {
    this.emit('error', new Error('format: archive format already set'));
    return this;
  }

  this._format = format;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} format The archive format to use.
 * @param  {Object} options See [Archiver]{@link Archiver}
 * @return {Archiver}
 */
vending.create = function(format, options) {
  if (formats[format]) {
    var instance = new Archiver(format, options);
    instance.<span class="apidocCodeKeywordSpan">setFormat</span>(format);
    instance.setModule(new formats[format](options));

    return instance;
  } else {
    throw new Error('create(' + format + '): format not registered');
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.setModule" id="apidoc.element.archiver.core.prototype.setModule">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>setModule
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setModule = function (module) {
  if (this._state.aborted) {
    this.emit('error', new Error('module: archive was aborted'));
    return this;
  }

  if (this._state.module) {
    this.emit('error', new Error('module: module already set'));
    return this;
  }

  this._module = module;
  this._modulePipe();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Object} options See [Archiver]{@link Archiver}
 * @return {Archiver}
 */
vending.create = function(format, options) {
  if (formats[format]) {
    var instance = new Archiver(format, options);
    instance.setFormat(format);
    instance.<span class="apidocCodeKeywordSpan">setModule</span>(new formats[format](options));

    return instance;
  } else {
    throw new Error('create(' + format + '): format not registered');
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.core.prototype.use" id="apidoc.element.archiver.core.prototype.use">
        function <span class="apidocSignatureSpan">archiver.core.prototype.</span>use
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (plugin) {
  this._streams.push(plugin);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.json" id="apidoc.module.archiver.json">module archiver.json</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.json.json" id="apidoc.element.archiver.json.json">
        function <span class="apidocSignatureSpan">archiver.</span>json
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (options) {
  if (!(this instanceof Json)) {
    return new Json(options);
  }

  options = this.options = util.defaults(options, {});

  Transform.call(this, options);

  this.supports = {
    directory: true
  };

  this.files = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.json.super_" id="apidoc.element.archiver.json.super_">
        function <span class="apidocSignatureSpan">archiver.json.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.json.prototype" id="apidoc.module.archiver.json.prototype">module archiver.json.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.json.prototype._transform" id="apidoc.element.archiver.json.prototype._transform">
        function <span class="apidocSignatureSpan">archiver.json.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  callback(null, chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.json.prototype._writeStringified" id="apidoc.element.archiver.json.prototype._writeStringified">
        function <span class="apidocSignatureSpan">archiver.json.prototype.</span>_writeStringified
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_writeStringified = function () {
  var fileString = JSON.stringify(this.files);
  this.write(fileString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* [finalize description]
*
* @return void
*/
Json.prototype.finalize = function() {
 this.<span class="apidocCodeKeywordSpan">_writeStringified</span>();
 this.end();
};

module.exports = Json;

/**
* @typedef {Object} JsonOptions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.json.prototype.append" id="apidoc.element.archiver.json.prototype.append">
        function <span class="apidocSignatureSpan">archiver.json.prototype.</span>append
        <span class="apidocSignatureSpan">(source, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (source, data, callback) {
  var self = this;

  data.crc32 = 0;

  function onend(err, sourceBuffer) {
    if (err) {
      callback(err);
      return;
    }

    data.size = sourceBuffer.length || 0;
    data.crc32 = crc32.unsigned(sourceBuffer);

    self.files.push(data);

    callback(null, data);
  }

  if (data.sourceType === 'buffer') {
    onend(null, source);
  } else if (data.sourceType === 'stream') {
    util.collectStream(source, onend);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// pipe archive data to the file
archive.pipe(output);

// append a file from stream
var file1 = __dirname + '/file1.txt';
archive.<span class="apidocCodeKeywordSpan">append</span>(fs.createReadStream(file1), { name: 'file1.txt' });

// append a file from string
archive.append('string cheese!', { name: 'file2.txt' });

// append a file from buffer
var buffer3 = new Buffer('buff it!');
archive.append(buffer3, { name: 'file3.txt' });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.json.prototype.finalize" id="apidoc.element.archiver.json.prototype.finalize">
        function <span class="apidocSignatureSpan">archiver.json.prototype.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
  this._writeStringified();
  this.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// append files from a directory
archive.directory('subdir/');

// append files from a glob pattern
archive.glob('subdir/*.txt');

// finalize the archive (ie we are done appending files but streams have to finish yet)
archive.<span class="apidocCodeKeywordSpan">finalize</span>();
```

## Formats

Archiver ships with out of the box support for TAR and ZIP archives.

You can register additional formats with `registerFormat`.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.tar" id="apidoc.module.archiver.tar">module archiver.tar</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.tar.tar" id="apidoc.element.archiver.tar.tar">
        function <span class="apidocSignatureSpan">archiver.</span>tar
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tar = function (options) {
  if (!(this instanceof Tar)) {
    return new Tar(options);
  }

  options = this.options = util.defaults(options, {
    gzip: false
  });

  if (typeof options.gzipOptions !== 'object') {
    options.gzipOptions = {};
  }

  this.supports = {
    directory: true
  };

  this.engine = engine.pack(options);
  this.compressor = false;

  if (options.gzip) {
    this.compressor = zlib.createGzip(options.gzipOptions);
    this.compressor.on('error', this._onCompressorError.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.tar.prototype" id="apidoc.module.archiver.tar.prototype">module archiver.tar.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.tar.prototype._onCompressorError" id="apidoc.element.archiver.tar.prototype._onCompressorError">
        function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>_onCompressorError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onCompressorError = function (err) {
  this.engine.emit('error', err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.tar.prototype.append" id="apidoc.element.archiver.tar.prototype.append">
        function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>append
        <span class="apidocSignatureSpan">(source, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (source, data, callback) {
  var self = this;

  data.mtime = data.date;

  function append(err, sourceBuffer) {
    if (err) {
      callback(err);
      return;
    }

    self.engine.entry(data, sourceBuffer, function(err) {
      callback(err, data);
    });
  }

  if (data.sourceType === 'buffer') {
    append(null, source);
  } else if (data.sourceType === 'stream' &amp;&amp; data._stats) {
    data.size = data._stats.size;

    var entry = self.engine.entry(data, function(err) {
      callback(err, data);
    });

    source.pipe(entry);
  } else if (data.sourceType === 'stream') {
    util.collectStream(source, append);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// pipe archive data to the file
archive.pipe(output);

// append a file from stream
var file1 = __dirname + '/file1.txt';
archive.<span class="apidocCodeKeywordSpan">append</span>(fs.createReadStream(file1), { name: 'file1.txt' });

// append a file from string
archive.append('string cheese!', { name: 'file2.txt' });

// append a file from buffer
var buffer3 = new Buffer('buff it!');
archive.append(buffer3, { name: 'file3.txt' });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.tar.prototype.finalize" id="apidoc.element.archiver.tar.prototype.finalize">
        function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
  this.engine.finalize();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// append files from a directory
archive.directory('subdir/');

// append files from a glob pattern
archive.glob('subdir/*.txt');

// finalize the archive (ie we are done appending files but streams have to finish yet)
archive.<span class="apidocCodeKeywordSpan">finalize</span>();
```

## Formats

Archiver ships with out of the box support for TAR and ZIP archives.

You can register additional formats with `registerFormat`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.tar.prototype.on" id="apidoc.element.archiver.tar.prototype.on">
        function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  return this.engine.on.apply(this.engine, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// create a file to stream archive data to.
var output = fs.createWriteStream(__dirname + '/example.zip');
var archive = archiver('zip', {
  store: true // Sets the compression method to STORE.
});

// listen for all archive data to be written
output.<span class="apidocCodeKeywordSpan">on</span>('close', function() {
console.log(archive.pointer() + ' total bytes');
console.log('archiver has been finalized and the output file descriptor has closed.');
});

// good practice to catch this error explicitly
archive.on('error', function(err) {
throw err;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.tar.prototype.pipe" id="apidoc.element.archiver.tar.prototype.pipe">
        function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>pipe
        <span class="apidocSignatureSpan">(destination, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (destination, options) {
  if (this.compressor) {
    return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
  } else {
    return this.engine.pipe.apply(this.engine, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// good practice to catch this error explicitly
archive.on('error', function(err) {
  throw err;
});

// pipe archive data to the file
archive.<span class="apidocCodeKeywordSpan">pipe</span>(output);

// append a file from stream
var file1 = __dirname + '/file1.txt';
archive.append(fs.createReadStream(file1), { name: 'file1.txt' });

// append a file from string
archive.append('string cheese!', { name: 'file2.txt' });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.tar.prototype.unpipe" id="apidoc.element.archiver.tar.prototype.unpipe">
        function <span class="apidocSignatureSpan">archiver.tar.prototype.</span>unpipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpipe = function () {
  if (this.compressor) {
    return this.compressor.unpipe.apply(this.compressor, arguments);
  } else {
    return this.engine.unpipe.apply(this.engine, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Unpipes the module from our internal stream.
*
* @private
* @return void
*/
Archiver.prototype._moduleUnpipe = function() {
 this._module.<span class="apidocCodeKeywordSpan">unpipe</span>(this);
 this._state.modulePiped = false;
};

/**
* Normalizes entry data with fallbacks for key properties.
*
* @private
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.zip" id="apidoc.module.archiver.zip">module archiver.zip</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.zip.zip" id="apidoc.element.archiver.zip.zip">
        function <span class="apidocSignatureSpan">archiver.</span>zip
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function (options) {
  if (!(this instanceof Zip)) {
    return new Zip(options);
  }

  options = this.options = util.defaults(options, {
    comment: '',
    forceUTC: false,
    store: false
  });

  this.supports = {
    directory: true
  };

  this.engine = new engine(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.archiver.zip.prototype" id="apidoc.module.archiver.zip.prototype">module archiver.zip.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.archiver.zip.prototype.append" id="apidoc.element.archiver.zip.prototype.append">
        function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>append
        <span class="apidocSignatureSpan">(source, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (source, data, callback) {
  this.engine.entry(source, data, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// pipe archive data to the file
archive.pipe(output);

// append a file from stream
var file1 = __dirname + '/file1.txt';
archive.<span class="apidocCodeKeywordSpan">append</span>(fs.createReadStream(file1), { name: 'file1.txt' });

// append a file from string
archive.append('string cheese!', { name: 'file2.txt' });

// append a file from buffer
var buffer3 = new Buffer('buff it!');
archive.append(buffer3, { name: 'file3.txt' });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.zip.prototype.finalize" id="apidoc.element.archiver.zip.prototype.finalize">
        function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
  this.engine.finalize();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// append files from a directory
archive.directory('subdir/');

// append files from a glob pattern
archive.glob('subdir/*.txt');

// finalize the archive (ie we are done appending files but streams have to finish yet)
archive.<span class="apidocCodeKeywordSpan">finalize</span>();
```

## Formats

Archiver ships with out of the box support for TAR and ZIP archives.

You can register additional formats with `registerFormat`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.zip.prototype.on" id="apidoc.element.archiver.zip.prototype.on">
        function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  return this.engine.on.apply(this.engine, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// create a file to stream archive data to.
var output = fs.createWriteStream(__dirname + '/example.zip');
var archive = archiver('zip', {
  store: true // Sets the compression method to STORE.
});

// listen for all archive data to be written
output.<span class="apidocCodeKeywordSpan">on</span>('close', function() {
console.log(archive.pointer() + ' total bytes');
console.log('archiver has been finalized and the output file descriptor has closed.');
});

// good practice to catch this error explicitly
archive.on('error', function(err) {
throw err;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.zip.prototype.pipe" id="apidoc.element.archiver.zip.prototype.pipe">
        function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {
  return this.engine.pipe.apply(this.engine, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// good practice to catch this error explicitly
archive.on('error', function(err) {
  throw err;
});

// pipe archive data to the file
archive.<span class="apidocCodeKeywordSpan">pipe</span>(output);

// append a file from stream
var file1 = __dirname + '/file1.txt';
archive.append(fs.createReadStream(file1), { name: 'file1.txt' });

// append a file from string
archive.append('string cheese!', { name: 'file2.txt' });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.archiver.zip.prototype.unpipe" id="apidoc.element.archiver.zip.prototype.unpipe">
        function <span class="apidocSignatureSpan">archiver.zip.prototype.</span>unpipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpipe = function () {
  return this.engine.unpipe.apply(this.engine, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Unpipes the module from our internal stream.
*
* @private
* @return void
*/
Archiver.prototype._moduleUnpipe = function() {
 this._module.<span class="apidocCodeKeywordSpan">unpipe</span>(this);
 this._state.modulePiped = false;
};

/**
* Normalizes entry data with fallbacks for key properties.
*
* @private
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>